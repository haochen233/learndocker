## 1.1 Docker简介
&emsp;&emsp;对Docker来说，它得益于现代Linux内核特性，如控件组（control group）、命名空间（namespace）技术，容器和宿主机之间的隔离更加彻底，容器有独立的网络和存储栈，还拥有自己的资源管理能力，使得同一台宿主机中的多个容器可以友好地共存。
&emsp;&emsp;Docker是一个能够把开发的应用程序自动部署到容器的开源引擎。那Docker有什么特别之处呢？Docker在虚拟化的容器执行环境中增加一个应用程序部署引擎。
### 1.1.1 Docker提供一个简单、轻量的建模方式
&emsp;&emsp;可以创建容器来运行应用程序了，大多数Docker容器只需不到1秒钟即可启动。同一台宿主机也可以运行更多的容器，使用户可以尽可能充分地利用系统资源。
### 1.1.2 职责的逻辑分离
&emsp;&emsp;使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器，Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的环境的一致性。

### 1.1.3 快速、高效的开发生命周期
&emsp;&emsp;Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性、易于构建，并易于协作。
### 1.1.4 鼓励使用面向服务的架构
&emsp;&emsp;Docker***推荐***单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。
## 1.2 Docker组件
这是Docker的核心组件：
* Docker客户端和服务器；
* Docker镜像；
* Registry；
* Docker容器；
### 1.2.1 Docker客户端和服务器
&emsp;&emsp;Docker是一个C/S（Client和Server）架构的程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程
### 1.2.2 Docker镜像  
&emsp;&emsp;镜像是构建Docker世界的**基石**。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“**构建**”部分。镜像是基于联合文件系统的一种层式的结构，由一系列指令一步一步构建出来。例如;
- 添加一个文件；
- 执行一个名令；
- 打开一个端口；  
&emsp;&emsp;可以把镜像当做容器的“**源代码**”。镜像体积很小，非常“**便携**”，易于分享、存储和更新。
### 1.2.3 Registry
&emsp;&emsp;Docker用**Registry**来保存用户构建的镜像。**registry**分为共有和私有两种。Docker公司运营的公共Registry叫作Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像。

&emsp;&emsp;你甚至可以假设自己的私有**registry**。
### 1.2.4 容器
&emsp;&emsp;Docker可以帮你构建和部署容器，你只需要把自己的应用程序或服务打包放进容器即可。  

&emsp;&emsp;我们可以认为，镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。  
&emsp;&emsp;总结起来，Docker容器就是：  
- 一个镜像格式；
- 一系列标准的操作；
- 一个执行环境；  
&emsp;&emsp;Docker借鉴了标准集装箱的概念，标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计哲学中。不同的是：集装箱运输货物，而Docker运输软件。  
&emsp;&emsp;每个容器都包含一个软件镜像。容器里面的进项可以进行一些操作。例如，镜像可以被**创建、启动、关闭、重启以及销毁**。  
&emsp;&emsp;Docker在执行上面的操作时，并不关心容器中到底塞进了什么用途的东西。所有容器都按照相同的方式将内容“**装载**”进去。  
&emsp;&emsp;Docker也不关心你要把容器运到何方，你可以在自己的笔记本构建容器，上传到“**Registry**”，然后下载到物理或虚拟的服务器来测试，再把容器部署到主机的集群中去，就像标准集装箱一样。Docker容器方便替换，可以叠加，易于分发，并且尽量通用。
## 1.3 我们能用Docker做什么
Docker的一些应用场景如下：  
- 加速本地开发和构建流程，使其更加高效、更加轻量化。本地开发人员可以构建、运行并分享Docker容器。  
- 能让独立服务或应用程序在不同的环境中，得到相同的运算结果。这一点在面向服务的架构和重度依赖卫星服务的部署中尤其实用。  
- 用Docker创建隔离的环境来测试。例如，用Jenkins CI这样的持续集成工具启动一个用于测试的容器。  
- Docker可以让开发者先在本机构建一个复杂的程序或架构来进行测试，而不是一开始就在生产环境部署、测试。  
- 构建一个多用户的平台即服务（Paas）基础设施  
- 为开发、测试提供一个轻量级的独立沙盒环境。  
- 提供软件即服务（Saas）应用程序，如Memcached即服务。  
- 高性能、超大规模的宿主机部署。
## 1.4 Docker与配置管理
&emsp;&emsp;

## 1.5 Docker的技术组件
&emsp;&emsp;一个原生的Linux容器格式，Docker中称为libcontainer。libcontainer格式现在是Docker容器的默认格式。  
&emsp;&emsp;Linux内核的命名空间（namespace），用于隔离文件系统、进程和网络。  
* 文件系统隔离：每个容器都有自己的root文件系统。
* 进程隔离：每个容器都运行在自己的进程环境中。
* 网络隔离：容器间的虚拟网络接口和IP地址都是分开的。
* 资源隔离和分组：使用cgroups（即 control group，Linux的内核特性之一）将CPU和内存之类的资源独立分配给每个Docker容器。
* 写时复制：文件系统都是通过写时复制创建的，这就意味着文件系统是分层的、快速的，而且占用的磁盘空间更小。
* 日志：容器产生的STDOUT、STDERR和STDIN这些IO流都会被收集并记入日志，用来进行日志分析和故障排错。
* 交互式shell：用户可以创建一个伪tty终端，将其连接到STDIN，为容器提供一个交互式的shell。